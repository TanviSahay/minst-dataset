"""Collect *-fix.csv's generated by annotate.py using the segment_index.csv,
sanitize their path names, and save them to their final resting place.
(Also checks the values while it's at it.)

DISCLAIMER (CBJ; July 20, 2016): this is set up to work nicely with RWC,
 the way I annotated those using my edits to annotate.py. It may or may not
 work for you. Hopefully you should just be able to use the outputs.

Usage:
collect_onsets.py <segment_index> <output_dir>
collect_onsets.py <segment_index> <output_dir> --dry-run
collect_onsets.py -h | --help

Arguments:
 segment_index   Path to the segment_index.csv, same as used by annotate.py.
 output_dir      Path to the directory to move the .csvs to.

Options:
 -h, --help      Print help.
 --dry-run       Run program without writing the files to the output_dir
"""
from __future__ import print_function
import boltons.fileutils
from docopt import docopt
import os
import pandas as pd


def fix_filepath(filepath):
    return filepath.replace('.csv', '-fix.csv')


def collect_onsets(segment_index_path, output_dir, dry_run=False):
    """
    Parameters
    ----------
    segment_index_path : str
        Path to the segment index file, which will be used to collect
        the files to process.

    output_dir : str
        Where the processed files get dumped.

    dry_run : bool
        If true, don't actually write anything; just print it to screen.
    """
    dframe = pd.read_csv(segment_index_path, index_col=1)
    print("begin collect_onsets()")
    print("segment_index contains {} rows.".format(len(dframe)))
    instrument_dframe = dframe.loc[dframe['instrument'].dropna().index]
    print("of which {} contain defined instruments. Ignoring the rest.".format(
        len(instrument_dframe)))

    instrument_dframe['onsets'] = instrument_dframe['logcqt'].str.replace(
        '.csv', '-fix.csv')
    onsets_exist = instrument_dframe['onsets'].map(
        os.path.exists)
    print("Valid fix files available: {}".format(onsets_exist.sum()))

    onset_count = 0
    for idx, row in instrument_dframe.iterrows():
        # Load csv data
        onsets_file = row['onsets']
        onsets = pd.read_csv(onsets_file, index_col=0)
        # make sure none are less than zero
        if (onsets['time'] < 0).any():
            onsets.loc[onsets['time'] < 0, 'time'] = 0.0
            print("Correcting negatives for", onsets_file)

        # reorder them to sorted.
        onsets = onsets.sort_values('time').reset_index(drop=True)
        onset_count += len(onsets)

        # Write it back out to output_dir with better filename.
        output_file = "{}.csv".format(row.name)
        output_path = os.path.join(output_dir, output_file)
        if not dry_run:
            boltons.fileutils.mkdir_p(output_dir)
            print("Writing:", output_path)
            onsets.to_csv(output_path)
        else:
            print("[Not Actually] Writing:", output_path)

    print("{} onsets were collected from {} files.".format(
        onset_count, len(instrument_dframe)))


if __name__ == "__main__":
    arguments = docopt(__doc__)
    collect_onsets(arguments.get('<segment_index>'),
                   arguments.get('<output_dir>'),
                   arguments.get('--dry-run'))
